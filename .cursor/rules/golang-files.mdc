---
globs: *.go
---

# Go Files (.go) Rules

## Language Version & Features
- Target **Go 1.25+** (or latest stable release).
- Use modern Go features where appropriate:
  - Generics for type safety.
  - `context` for request lifecycle and cancellation.
  - Error wrapping with `%w` (`fmt.Errorf`).
  - Structured logging (e.g., `slog` or another unified logger).
  - Embedding for code reuse.
  - Range-over-function (Go 1.25+).

## Code Style
- Use **tabs** for indentation (Go standard).
- Always run `gofmt` and `goimports` before commit.
- Naming conventions:
  - **Exported identifiers**: PascalCase.
  - **Unexported identifiers**: camelCase.
  - **Constants**: ALL_CAPS or PascalCase (project-wide consistency).
- Prefer short variable names in tight/local scopes (`i`, `n`, `err`).

## Package Organization
- Package names: short, lowercase, no underscores or plurals.
- Group related functionality logically; avoid large "god packages".
- Keep `main` package minimal â€” delegate logic to internal packages.

## Error Handling
- Always handle returned errors explicitly.
- Wrap errors with context:  
  `fmt.Errorf("reading config: %w", err)`
- Define custom error types where domain-specific.
- Avoid panics in normal control flow.

## Logging
- Use **structured logging** consistently.
- Always include relevant context (IDs, keys, parameters).
- Apply proper levels: Debug, Info, Warn, Error.
- Logging libraries should be pinned and unified across the project.

## Concurrency
- Always use `context.Context` for timeouts and cancellation.
- Manage goroutine lifecycles explicitly; avoid leaks.
- Prefer channels or message passing to shared mutable state.
- Use `sync` primitives only when truly required.

## Best Practices
- Prefer **composition over inheritance**.
- Use **interfaces** to abstract behavior, not just for testing.
- Keep functions small and cohesive.
- Return early to reduce nesting.
- Avoid global state; prefer dependency injection or constructors.
- Document exported symbols with comments starting with the identifier name.

## Database / External Resources
- Encapsulate data access behind clear interfaces (e.g., repository pattern).
- Use transactions for multi-step operations where consistency is required.
- Clean up connections and resources (`defer close(...)`).