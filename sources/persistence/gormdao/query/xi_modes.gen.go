// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ximanager/sources/persistence/entities"
)

func newMode(db *gorm.DB, opts ...gen.DOOption) mode {
	_mode := mode{}

	_mode.modeDo.UseDB(db, opts...)
	_mode.modeDo.UseModel(&entities.Mode{})

	tableName := _mode.modeDo.TableName()
	_mode.ALL = field.NewAsterisk(tableName)
	_mode.ID = field.NewField(tableName, "id")
	_mode.ChatID = field.NewInt64(tableName, "chat_id")
	_mode.Type = field.NewString(tableName, "type")
	_mode.Name = field.NewString(tableName, "name")
	_mode.Prompt = field.NewString(tableName, "prompt")
	_mode.Config = field.NewString(tableName, "config")
	_mode.IsEnabled = field.NewBool(tableName, "is_enabled")
	_mode.CreatedAt = field.NewTime(tableName, "created_at")
	_mode.CreatedBy = field.NewField(tableName, "created_by")
	_mode.SelectedModes = modeHasManySelectedModes{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SelectedModes", "entities.SelectedMode"),
		Mode: struct {
			field.RelationField
			Creator struct {
				field.RelationField
				Messages struct {
					field.RelationField
					User struct {
						field.RelationField
					}
				}
				Donations struct {
					field.RelationField
					UserEntity struct {
						field.RelationField
					}
				}
				CreatedModes struct {
					field.RelationField
				}
				SelectedModes struct {
					field.RelationField
				}
				Pins struct {
					field.RelationField
					UserEntity struct {
						field.RelationField
					}
				}
			}
			SelectedModes struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("SelectedModes.Mode", "entities.Mode"),
			Creator: struct {
				field.RelationField
				Messages struct {
					field.RelationField
					User struct {
						field.RelationField
					}
				}
				Donations struct {
					field.RelationField
					UserEntity struct {
						field.RelationField
					}
				}
				CreatedModes struct {
					field.RelationField
				}
				SelectedModes struct {
					field.RelationField
				}
				Pins struct {
					field.RelationField
					UserEntity struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("SelectedModes.Mode.Creator", "entities.User"),
				Messages: struct {
					field.RelationField
					User struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("SelectedModes.Mode.Creator.Messages", "entities.Message"),
					User: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("SelectedModes.Mode.Creator.Messages.User", "entities.User"),
					},
				},
				Donations: struct {
					field.RelationField
					UserEntity struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("SelectedModes.Mode.Creator.Donations", "entities.Donation"),
					UserEntity: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("SelectedModes.Mode.Creator.Donations.UserEntity", "entities.User"),
					},
				},
				CreatedModes: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("SelectedModes.Mode.Creator.CreatedModes", "entities.Mode"),
				},
				SelectedModes: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("SelectedModes.Mode.Creator.SelectedModes", "entities.SelectedMode"),
				},
				Pins: struct {
					field.RelationField
					UserEntity struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("SelectedModes.Mode.Creator.Pins", "entities.Pin"),
					UserEntity: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("SelectedModes.Mode.Creator.Pins.UserEntity", "entities.User"),
					},
				},
			},
			SelectedModes: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("SelectedModes.Mode.SelectedModes", "entities.SelectedMode"),
			},
		},
		User: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("SelectedModes.User", "entities.User"),
		},
	}

	_mode.Creator = modeBelongsToCreator{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Creator", "entities.User"),
	}

	_mode.fillFieldMap()

	return _mode
}

type mode struct {
	modeDo modeDo

	ALL           field.Asterisk
	ID            field.Field
	ChatID        field.Int64
	Type          field.String
	Name          field.String
	Prompt        field.String
	Config        field.String
	IsEnabled     field.Bool
	CreatedAt     field.Time
	CreatedBy     field.Field
	SelectedModes modeHasManySelectedModes

	Creator modeBelongsToCreator

	fieldMap map[string]field.Expr
}

func (m mode) Table(newTableName string) *mode {
	m.modeDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m mode) As(alias string) *mode {
	m.modeDo.DO = *(m.modeDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *mode) updateTableName(table string) *mode {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewField(table, "id")
	m.ChatID = field.NewInt64(table, "chat_id")
	m.Type = field.NewString(table, "type")
	m.Name = field.NewString(table, "name")
	m.Prompt = field.NewString(table, "prompt")
	m.Config = field.NewString(table, "config")
	m.IsEnabled = field.NewBool(table, "is_enabled")
	m.CreatedAt = field.NewTime(table, "created_at")
	m.CreatedBy = field.NewField(table, "created_by")

	m.fillFieldMap()

	return m
}

func (m *mode) WithContext(ctx context.Context) IModeDo { return m.modeDo.WithContext(ctx) }

func (m mode) TableName() string { return m.modeDo.TableName() }

func (m mode) Alias() string { return m.modeDo.Alias() }

func (m mode) Columns(cols ...field.Expr) gen.Columns { return m.modeDo.Columns(cols...) }

func (m *mode) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *mode) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 11)
	m.fieldMap["id"] = m.ID
	m.fieldMap["chat_id"] = m.ChatID
	m.fieldMap["type"] = m.Type
	m.fieldMap["name"] = m.Name
	m.fieldMap["prompt"] = m.Prompt
	m.fieldMap["config"] = m.Config
	m.fieldMap["is_enabled"] = m.IsEnabled
	m.fieldMap["created_at"] = m.CreatedAt
	m.fieldMap["created_by"] = m.CreatedBy

}

func (m mode) clone(db *gorm.DB) mode {
	m.modeDo.ReplaceConnPool(db.Statement.ConnPool)
	m.SelectedModes.db = db.Session(&gorm.Session{Initialized: true})
	m.SelectedModes.db.Statement.ConnPool = db.Statement.ConnPool
	m.Creator.db = db.Session(&gorm.Session{Initialized: true})
	m.Creator.db.Statement.ConnPool = db.Statement.ConnPool
	return m
}

func (m mode) replaceDB(db *gorm.DB) mode {
	m.modeDo.ReplaceDB(db)
	m.SelectedModes.db = db.Session(&gorm.Session{})
	m.Creator.db = db.Session(&gorm.Session{})
	return m
}

type modeHasManySelectedModes struct {
	db *gorm.DB

	field.RelationField

	Mode struct {
		field.RelationField
		Creator struct {
			field.RelationField
			Messages struct {
				field.RelationField
				User struct {
					field.RelationField
				}
			}
			Donations struct {
				field.RelationField
				UserEntity struct {
					field.RelationField
				}
			}
			CreatedModes struct {
				field.RelationField
			}
			SelectedModes struct {
				field.RelationField
			}
			Pins struct {
				field.RelationField
				UserEntity struct {
					field.RelationField
				}
			}
		}
		SelectedModes struct {
			field.RelationField
		}
	}
	User struct {
		field.RelationField
	}
}

func (a modeHasManySelectedModes) Where(conds ...field.Expr) *modeHasManySelectedModes {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a modeHasManySelectedModes) WithContext(ctx context.Context) *modeHasManySelectedModes {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a modeHasManySelectedModes) Session(session *gorm.Session) *modeHasManySelectedModes {
	a.db = a.db.Session(session)
	return &a
}

func (a modeHasManySelectedModes) Model(m *entities.Mode) *modeHasManySelectedModesTx {
	return &modeHasManySelectedModesTx{a.db.Model(m).Association(a.Name())}
}

func (a modeHasManySelectedModes) Unscoped() *modeHasManySelectedModes {
	a.db = a.db.Unscoped()
	return &a
}

type modeHasManySelectedModesTx struct{ tx *gorm.Association }

func (a modeHasManySelectedModesTx) Find() (result []*entities.SelectedMode, err error) {
	return result, a.tx.Find(&result)
}

func (a modeHasManySelectedModesTx) Append(values ...*entities.SelectedMode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a modeHasManySelectedModesTx) Replace(values ...*entities.SelectedMode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a modeHasManySelectedModesTx) Delete(values ...*entities.SelectedMode) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a modeHasManySelectedModesTx) Clear() error {
	return a.tx.Clear()
}

func (a modeHasManySelectedModesTx) Count() int64 {
	return a.tx.Count()
}

func (a modeHasManySelectedModesTx) Unscoped() *modeHasManySelectedModesTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type modeBelongsToCreator struct {
	db *gorm.DB

	field.RelationField
}

func (a modeBelongsToCreator) Where(conds ...field.Expr) *modeBelongsToCreator {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a modeBelongsToCreator) WithContext(ctx context.Context) *modeBelongsToCreator {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a modeBelongsToCreator) Session(session *gorm.Session) *modeBelongsToCreator {
	a.db = a.db.Session(session)
	return &a
}

func (a modeBelongsToCreator) Model(m *entities.Mode) *modeBelongsToCreatorTx {
	return &modeBelongsToCreatorTx{a.db.Model(m).Association(a.Name())}
}

func (a modeBelongsToCreator) Unscoped() *modeBelongsToCreator {
	a.db = a.db.Unscoped()
	return &a
}

type modeBelongsToCreatorTx struct{ tx *gorm.Association }

func (a modeBelongsToCreatorTx) Find() (result *entities.User, err error) {
	return result, a.tx.Find(&result)
}

func (a modeBelongsToCreatorTx) Append(values ...*entities.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a modeBelongsToCreatorTx) Replace(values ...*entities.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a modeBelongsToCreatorTx) Delete(values ...*entities.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a modeBelongsToCreatorTx) Clear() error {
	return a.tx.Clear()
}

func (a modeBelongsToCreatorTx) Count() int64 {
	return a.tx.Count()
}

func (a modeBelongsToCreatorTx) Unscoped() *modeBelongsToCreatorTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type modeDo struct{ gen.DO }

type IModeDo interface {
	gen.SubQuery
	Debug() IModeDo
	WithContext(ctx context.Context) IModeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IModeDo
	WriteDB() IModeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IModeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IModeDo
	Not(conds ...gen.Condition) IModeDo
	Or(conds ...gen.Condition) IModeDo
	Select(conds ...field.Expr) IModeDo
	Where(conds ...gen.Condition) IModeDo
	Order(conds ...field.Expr) IModeDo
	Distinct(cols ...field.Expr) IModeDo
	Omit(cols ...field.Expr) IModeDo
	Join(table schema.Tabler, on ...field.Expr) IModeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IModeDo
	RightJoin(table schema.Tabler, on ...field.Expr) IModeDo
	Group(cols ...field.Expr) IModeDo
	Having(conds ...gen.Condition) IModeDo
	Limit(limit int) IModeDo
	Offset(offset int) IModeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IModeDo
	Unscoped() IModeDo
	Create(values ...*entities.Mode) error
	CreateInBatches(values []*entities.Mode, batchSize int) error
	Save(values ...*entities.Mode) error
	First() (*entities.Mode, error)
	Take() (*entities.Mode, error)
	Last() (*entities.Mode, error)
	Find() ([]*entities.Mode, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entities.Mode, err error)
	FindInBatches(result *[]*entities.Mode, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*entities.Mode) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IModeDo
	Assign(attrs ...field.AssignExpr) IModeDo
	Joins(fields ...field.RelationField) IModeDo
	Preload(fields ...field.RelationField) IModeDo
	FirstOrInit() (*entities.Mode, error)
	FirstOrCreate() (*entities.Mode, error)
	FindByPage(offset int, limit int) (result []*entities.Mode, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IModeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m modeDo) Debug() IModeDo {
	return m.withDO(m.DO.Debug())
}

func (m modeDo) WithContext(ctx context.Context) IModeDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m modeDo) ReadDB() IModeDo {
	return m.Clauses(dbresolver.Read)
}

func (m modeDo) WriteDB() IModeDo {
	return m.Clauses(dbresolver.Write)
}

func (m modeDo) Session(config *gorm.Session) IModeDo {
	return m.withDO(m.DO.Session(config))
}

func (m modeDo) Clauses(conds ...clause.Expression) IModeDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m modeDo) Returning(value interface{}, columns ...string) IModeDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m modeDo) Not(conds ...gen.Condition) IModeDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m modeDo) Or(conds ...gen.Condition) IModeDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m modeDo) Select(conds ...field.Expr) IModeDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m modeDo) Where(conds ...gen.Condition) IModeDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m modeDo) Order(conds ...field.Expr) IModeDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m modeDo) Distinct(cols ...field.Expr) IModeDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m modeDo) Omit(cols ...field.Expr) IModeDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m modeDo) Join(table schema.Tabler, on ...field.Expr) IModeDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m modeDo) LeftJoin(table schema.Tabler, on ...field.Expr) IModeDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m modeDo) RightJoin(table schema.Tabler, on ...field.Expr) IModeDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m modeDo) Group(cols ...field.Expr) IModeDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m modeDo) Having(conds ...gen.Condition) IModeDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m modeDo) Limit(limit int) IModeDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m modeDo) Offset(offset int) IModeDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m modeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IModeDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m modeDo) Unscoped() IModeDo {
	return m.withDO(m.DO.Unscoped())
}

func (m modeDo) Create(values ...*entities.Mode) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m modeDo) CreateInBatches(values []*entities.Mode, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m modeDo) Save(values ...*entities.Mode) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m modeDo) First() (*entities.Mode, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entities.Mode), nil
	}
}

func (m modeDo) Take() (*entities.Mode, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entities.Mode), nil
	}
}

func (m modeDo) Last() (*entities.Mode, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entities.Mode), nil
	}
}

func (m modeDo) Find() ([]*entities.Mode, error) {
	result, err := m.DO.Find()
	return result.([]*entities.Mode), err
}

func (m modeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entities.Mode, err error) {
	buf := make([]*entities.Mode, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m modeDo) FindInBatches(result *[]*entities.Mode, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m modeDo) Attrs(attrs ...field.AssignExpr) IModeDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m modeDo) Assign(attrs ...field.AssignExpr) IModeDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m modeDo) Joins(fields ...field.RelationField) IModeDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m modeDo) Preload(fields ...field.RelationField) IModeDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m modeDo) FirstOrInit() (*entities.Mode, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entities.Mode), nil
	}
}

func (m modeDo) FirstOrCreate() (*entities.Mode, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entities.Mode), nil
	}
}

func (m modeDo) FindByPage(offset int, limit int) (result []*entities.Mode, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m modeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m modeDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m modeDo) Delete(models ...*entities.Mode) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *modeDo) withDO(do gen.Dao) *modeDo {
	m.DO = *do.(*gen.DO)
	return m
}
